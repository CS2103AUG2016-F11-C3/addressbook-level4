# A0092390E
###### \java\seedu\address\model\item\Item.java
``` java
	 */
    @Override
	public boolean is(String query){
    	query = query.toLowerCase();
		switch (query) {
		case "done":
			return this.getIsDone();
		case "undone":
		    return !this.getIsDone();
		case "event":
			return this.getStartDate() != null;
		case "task":
			return this.getStartDate() == null;
		case "overdue":
			return this.getEndDate() != null && this.getIsDone() == false
					&& this.getEndDate().isAfter(LocalDateTime.now());
		case "item":
		    return true;
		default:
			return false;
		}
    }

	/**
	 * Returns the type of the item. Useful for Item cards and messages.
	 * 
	 * @return The type of the item, computed based on start/end dates.
	 *         [Event|Floating Task|Task]
```
###### \java\seedu\address\model\item\Item.java
``` java
	 */
	@Override
	public String getType() {
		if (this.getStartDate() != null) {
			return "Event";
		} else if (this.getEndDate() == null) {
			return "Floating Task";
		} else {
			return "Task";
		}
	}

	/**
	 * Replaces this Item's tags with the tags in the argument tag list.
	 */
    public void setTags(UniqueTagList replacement) {
        tags.setTags(replacement);
		setChanged();
		notifyObservers();
    }

    
    @Override
	public void setIsDone(boolean doneness) {
        this.isDone = doneness;
		setChanged();
		notifyObservers();
    }

    public void setStartDate(LocalDateTime startDate) {
        this.startDate = startDate;
		setChanged();
		notifyObservers();
    }

    public void setEndDate(LocalDateTime endDate) {
        this.endDate = endDate;
		setChanged();
		notifyObservers();
    }

    public void setRecurring(boolean isRecurring) {
        this.isRecurring = isRecurring;
		setChanged();
		notifyObservers();
    }

    public void setRecurInterval(Period recurInterval) {
        this.recurInterval = recurInterval;
		setChanged();
		notifyObservers();
    }

    public void setRecurEndDate(LocalDateTime recurEndDate) {
        this.recurEndDate = recurEndDate;
		setChanged();
		notifyObservers();
	}

	public void setDescription(String desc) throws IllegalValueException {
		this.description.setFullDescription(desc);
		setChanged();
		notifyObservers();
	}
    @Override
    public int hashCode() {
        // use this method for custom fields hashing instead of implementing
        // your own
        return Objects.hash(description);
    }

    @Override
    public String toString() {
        return description.toString();
    }


    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof ReadOnlyItem // instanceof handles nulls
                && this.isSameStateAs((ReadOnlyItem) other));
    }

    @Override
    /**
     * sort by start date then end date then alphabetically
     * for UI chronological sort
     * @author darren
     */
    public int compareTo(Item other) {
        LocalDateTime thisStart, thisEnd, otherStart, otherEnd;
        
        thisStart = assignDummyLDT(startDate);
        thisEnd = assignDummyLDT(endDate);
        otherStart = assignDummyLDT(other.getStartDate());
        otherEnd = assignDummyLDT(other.getEndDate());
        
        if(thisStart.isBefore(otherStart)) {
            // this item starts earlier
            return -1;
        } else if(thisStart.isAfter(otherStart)) {
            // this item starts later
            return 1;
        } else {
            // both have same start datetime
            if(thisEnd.isBefore(otherEnd)) {
                return -1;
            } else if(thisEnd.isAfter(otherEnd)){
                return 1;
            }
        }
        
        // same start and end date
        // sort alphabetically by description
        return description.compareTo(other.getDescription());
    }

    /**
     * assign the max LocalDateTime as a dummy to a java.time.LocalDateTime
     * object if necessary
     * @param checkee
     * @return
     * @author darren
     */
    private LocalDateTime assignDummyLDT(LocalDateTime checkee) {
        if(checkee == null) {
            return LocalDateTime.MAX;
        }
        
        return checkee;
    }
    
    /**
     * Returns a deep copy of the current Item
     * 
     * @return deep copy of this Item
```
###### \java\seedu\address\model\ModelManager.java
``` java
    private class Keyword {
        private String keyword;

        Keyword(String _keyword) {
            keyword = _keyword;
        }

        public boolean search(ReadOnlyItem item) {
            if (keyword.matches(Parser.COMMAND_DESCRIPTION_REGEX)) {
                return StringUtil.containsIgnoreCase(item.getDescription().getFullDescription(),
                        keyword.replace(Parser.COMMAND_DESCRIPTION_PREFIX, ""));
            } else if (keyword.matches(Parser.COMMAND_TAG_REGEX)) {
                return StringUtil.containsIgnoreCase(item.getTags().listTags(),
                        keyword.replaceFirst(Parser.COMMAND_TAG_PREFIX, ""));
            } else {
                DateTimeParser parseDate = new DateTimeParser(keyword);
                return ((item.getStartDate() != null
                        && DateTimeParser.isSameDay(item.getStartDate(), parseDate.extractStartDate())
                        || (item.getEndDate() != null
                                && DateTimeParser.isSameDay(item.getEndDate(), parseDate.extractStartDate()))));
            }
        }
    }

}
```
