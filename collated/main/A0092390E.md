# A0092390E
###### /java/seedu/address/logic/commands/CommandResult.java
``` java
	 */
	public CommandResult(String feedbackToUser, ReadOnlyItem itemToComplete) {
		assert feedbackToUser != null;
		this.feedbackToUser = feedbackToUser;
		this.item = itemToComplete;
		this.clear = true;
	}

	public void setClear(boolean bool) {
		this.clear = bool;
	}

	public boolean getClear() {
		return this.clear;
	}
	public ReadOnlyItem getItem() {
		return this.item;
    }

}
```
###### /java/seedu/address/logic/commands/EditCommand.java
``` java
 */
public class EditCommand extends Command {

    public static final String COMMAND_WORD = "edit";

    public static final String MESSAGE_USAGE = COMMAND_WORD + "... edit ..."
            + ": Edits an existing item.\n"
            + "Syntax: edit CONTEXT_ID FIELD:NEW_DETAIL\n" + "Example: "
            + COMMAND_WORD + " 2 start:tomorrow 6pm";

    public static final String MESSAGE_SUCCESS = "Successfully edited: %1$s";
    public static final String MESSAGE_DUPLICATE_ITEM = "This task already exists in the to-do list";
    public static final String MESSAGE_INVALID_FIELD = "The available fields are: desc/description, start, end, by and period";
    public static final String MESSAGE_UNDO_SUCCESS = "Undo add task: %1$s";
    public static final String MESSAGE_UNDO_FAILURE = "Failed to undo task: %1$s";

    public static final String[] ALLOWED_FIELDS = { "desc", "description",
            "start", "end", "by", "period" };

    private Item itemToModify;
    private Item previousTemplate;
    public final int targetIndex;
    private ArrayList<String[]> editFields;

    /**
     * Constructor using raw strings
     * 
     * @param index:
     *            contextual Index of the Item being referenced
     * @param arguments:
     *            ArrayList of Strings (previously comma-delimited), each of
     *            which is a field:value pair
     * @throws IllegalValueException
     */
    public EditCommand(Integer index, ArrayList<String> arguments)
            throws IllegalValueException {
        this.targetIndex = index;
        assert arguments.size() != 0;

        editFields = new ArrayList<>();
        for (String argument : arguments) {
            editFields.add(argument.split(":", 2));
        }

        previousTemplate = new Item(new Description("dummy"), null, null,
                new UniqueTagList());
    }

    /**
     * Executes the edit command.
     * 
     * @author darren
```
###### /java/seedu/address/logic/parser/Parser.java
``` java
	 */
    private Command prepareEdit(String args) {
        final Matcher matcher = ITEM_EDIT_ARGS_FORMAT.matcher(args.trim());
        if (!matcher.matches()) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, EditCommand.MESSAGE_USAGE));
        }
        int index = Integer.parseInt(matcher.group("targetIndex"));
        ArrayList<String> arguments = parseMultipleParameters(matcher.group("arguments"), ',');
        try {
            return new EditCommand(index, arguments);
        } catch (IllegalValueException e) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, e.getMessage()));
        }
    }

	/*
	 * Extracts a valid DateTime from the provided arguments and adds them to
	 * the keywordSet, then returns true. If the arguments do not form a valid
	 * DateTime, returns false.
	 * 
	 * @param args
	 * @param keywordSet
	 * @return
	 */
    private boolean extractDateTimeFromKeywords(String args, final Set<String> keywordSet) {
        assert args != null;
        assert !args.isEmpty();
        assert keywordSet != null;
        DateTimeParser dateArgs = new DateTimeParser(args);
        
        if (dateArgs.extractStartDate() != null){
            keywordSet.add(dateArgs.extractStartDate().format(DATE_TIME_FORMATTER));
            if (dateArgs.extractEndDate()!= null){
                keywordSet.add(dateArgs.extractEndDate().format(DATE_TIME_FORMATTER));
            }
            return true;
        }
        else{
            return false;
        }
    }

    /**
     * Given a specific pattern, extracts all phrases that match the pattern and adds them
     * to keywordSet. Returns args string without the keywords that were extracted.
     * @param args
     * @param searchFormat
     * @return
```
###### /java/seedu/address/model/item/Item.java
``` java
 */
public class Item extends Observable implements ReadOnlyItem, Comparable<Item> {

    public static final Comparator<Item> chronologicalComparator = new Comparator<Item>(){
        @Override
        public int compare(Item x, Item y) {
            return x.compareTo(y);
        }
    };
;
    private UniqueTagList tags;
    private Description description;
    private boolean isDone;

    private LocalDateTime startDate;
    private LocalDateTime endDate;

    // for recurring events only
    private boolean isRecurring;
    private Period recurInterval;
    private LocalDateTime recurEndDate;

    /**
     * constructor for floating item
     */
    public Item(Description desc, UniqueTagList tags) {
        // assert !CollectionUtil.isAnyNull(name, phone, email, address, tags);
        assert desc != null;
        this.description = desc;
        this.isDone = false;
        this.tags = new UniqueTagList(tags);
    }

    /**
     * constructor for an item with a definite
     * start and end time (non-recurring)
     * @param desc
     * @param start
     * @param end
     * @author darren
     */
    public Item(Description desc, LocalDateTime start, LocalDateTime end, UniqueTagList tags) {
        assert !CollectionUtil.isAnyNull(desc);
        this.description = desc;
        this.startDate = start;
        this.endDate = end;
        this.tags = new UniqueTagList(tags);
    }
    
	/**
	 * constructor for an item with a definite end time only (non-recurring)
	 * 
	 * @param desc
	 * @param end
	 * @author darren
```
###### /java/seedu/address/model/item/Item.java
``` java
	 */
    @Override
	public boolean is(String query){
    	query = query.toLowerCase();
		switch (query) {
		case "done":
			return this.getIsDone();
		case "undone":
		    return !this.getIsDone();
		case "event":
			return this.getStartDate() != null;
		case "task":
			return this.getStartDate() == null;
		case "overdue":
			return this.getEndDate() != null && this.getIsDone() == false
					&& this.getEndDate().isAfter(LocalDateTime.now());
		case "item":
		    return true;
		default:
			return false;
		}
    }

	/**
	 * Returns the type of the item. Useful for Item cards and messages.
	 * 
	 * @return The type of the item, computed based on start/end dates.
	 *         [Event|Floating Task|Task]
```
###### /java/seedu/address/model/item/Item.java
``` java
	 */
	@Override
	public String getType() {
		if (this.getStartDate() != null) {
			return "Event";
		} else if (this.getEndDate() == null) {
			return "Floating Task";
		} else {
			return "Task";
		}
	}

	/**
	 * Replaces this Item's tags with the tags in the argument tag list.
	 */
    public void setTags(UniqueTagList replacement) {
        tags.setTags(replacement);
		setChanged();
		notifyObservers();
    }

    
    @Override
	public void setIsDone(boolean doneness) {
        this.isDone = doneness;
		setChanged();
		notifyObservers();
    }

    public void setStartDate(LocalDateTime startDate) {
        this.startDate = startDate;
		setChanged();
		notifyObservers();
    }

    public void setEndDate(LocalDateTime endDate) {
        this.endDate = endDate;
		setChanged();
		notifyObservers();
    }

    public void setRecurring(boolean isRecurring) {
        this.isRecurring = isRecurring;
		setChanged();
		notifyObservers();
    }

    public void setRecurInterval(Period recurInterval) {
        this.recurInterval = recurInterval;
		setChanged();
		notifyObservers();
    }

    public void setRecurEndDate(LocalDateTime recurEndDate) {
        this.recurEndDate = recurEndDate;
		setChanged();
		notifyObservers();
	}

	public void setDescription(String desc) throws IllegalValueException {
		this.description.setFullDescription(desc);
		setChanged();
		notifyObservers();
	}
    @Override
    public int hashCode() {
        // use this method for custom fields hashing instead of implementing
        // your own
        return Objects.hash(description);
    }

    @Override
    public String toString() {
        return description.toString();
    }


    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof ReadOnlyItem // instanceof handles nulls
                && this.isSameStateAs((ReadOnlyItem) other));
    }

    @Override
    /**
     * sort by start date then end date then alphabetically
     * for UI chronological sort
     * @author darren
     */
    public int compareTo(Item other) {
        LocalDateTime thisStart, thisEnd, otherStart, otherEnd;
        
        thisStart = assignDummyLDT(startDate);
        thisEnd = assignDummyLDT(endDate);
        otherStart = assignDummyLDT(other.getStartDate());
        otherEnd = assignDummyLDT(other.getEndDate());
        
        if(thisStart.isBefore(otherStart)) {
            // this item starts earlier
            return -1;
        } else if(thisStart.isAfter(otherStart)) {
            // this item starts later
            return 1;
        } else {
            // both have same start datetime
            if(thisEnd.isBefore(otherEnd)) {
                return -1;
            } else if(thisEnd.isAfter(otherEnd)){
                return 1;
            }
        }
        
        // same start and end date
        // sort alphabetically by description
        return description.compareTo(other.getDescription());
    }

    /**
     * assign the max LocalDateTime as a dummy to a java.time.LocalDateTime
     * object if necessary
     * @param checkee
     * @return
     * @author darren
     */
    private LocalDateTime assignDummyLDT(LocalDateTime checkee) {
        if(checkee == null) {
            return LocalDateTime.MAX;
        }
        
        return checkee;
    }
    
    /**
     * Returns a deep copy of the current Item
     * 
     * @return deep copy of this Item
```
###### /java/seedu/address/model/ModelManager.java
``` java
    private class Keyword {
        private String keyword;

        Keyword(String _keyword) {
            keyword = _keyword;
        }

        public boolean search(ReadOnlyItem item) {
            if (keyword.matches(Parser.COMMAND_DESCRIPTION_REGEX)) {
                return StringUtil.containsIgnoreCase(item.getDescription().getFullDescription(),
                        keyword.replace(Parser.COMMAND_DESCRIPTION_PREFIX, ""));
            } else if (keyword.matches(Parser.COMMAND_TAG_REGEX)) {
                return StringUtil.containsIgnoreCase(item.getTags().listTags(),
                        keyword.replaceFirst(Parser.COMMAND_TAG_PREFIX, ""));
            } else {
                DateTimeParser parseDate = new DateTimeParser(keyword);
                return ((item.getStartDate() != null
                        && DateTimeParser.isSameDay(item.getStartDate(), parseDate.extractStartDate())
                        || (item.getEndDate() != null
                                && DateTimeParser.isSameDay(item.getEndDate(), parseDate.extractStartDate()))));
            }
        }
    }

}
```
###### /java/seedu/address/ui/ItemCard.java
``` java
	 */
	private ArrayList<Label> getTypeLabel() {
		ArrayList<Label> labelList = new ArrayList<>();
		// To fix once we implement proper polymorphic Items
		Label newLabel = new Label(this.item.getType());
		newLabel.getStyleClass().add("lbl");
		newLabel.getStyleClass().add("lbl-warning");
		labelList.add(newLabel);
		if (this.item.getIsDone()) {
			newLabel = new Label("Done");
			newLabel.getStyleClass().add("lbl");
			newLabel.getStyleClass().add("lbl-success");
			labelList.add(newLabel);
		}
		return labelList;
	}

	private ArrayList<Label> getTags() {
		ArrayList<Label> labelList = new ArrayList<>();
		// To fix once we implement proper polymorphic Items
		for (Tag tag : this.item.getTags()) {
			Label newLabel = new Label(tag.tagName);
			newLabel.getStyleClass().add("lbl");
			newLabel.getStyleClass().add("lbl-info");
			labelList.add(newLabel);
		}
		return labelList;
	}

	// Use the observer pattern to be notified of changes in the underlying
	// model
	@Override
	public void update(Observable o, Object arg) {
		this.initialize();
	}
}
```
###### /resources/view/ItemListCard.fxml
``` fxml
            <children>
                <VBox alignment="CENTER_LEFT" maxHeight="150.0" minHeight="105.0" prefHeight="115.0" GridPane.columnIndex="0">
                    <stylesheets>
                        <URL value="@DarkTheme.css" />
                        <URL value="@Extensions.css" />
                    </stylesheets>
                    <padding>
                        <Insets bottom="5" left="15" right="5" top="5" />
                    </padding>
                    <children>
	                    <HBox fx:id="tags">
	                    
	                    </HBox>
                        <HBox spacing="5" alignment="CENTER_LEFT">
                            <children>
			                    <HBox>
                                    <Text fx:id="id" styleClass="cell_big_label"></Text>
                                    <Label fx:id="description" text="\$first" styleClass="cell_big_label"/>
                                </HBox>
                            </children>
                        </HBox>
	                    <Text fx:id="dates">
	                    </Text>
	                    <Text fx:id="relativeDate">
	                    </Text>
                    </children>
                </VBox>
            </children>
        </GridPane>
    </children>
</HBox>
```
